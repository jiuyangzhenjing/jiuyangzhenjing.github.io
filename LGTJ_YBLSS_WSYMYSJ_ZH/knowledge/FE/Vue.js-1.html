<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>为什么分析Vue源码 | 舒克张的个人博客</title>
    <meta name="description" content="我不想给自己打标签，也不想给自己划界线。">
    
    
    <link rel="preload" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/css/0.styles.a9148fe0.css" as="style"><link rel="preload" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/app.c54d493b.js" as="script"><link rel="preload" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/2.6219b60a.js" as="script"><link rel="preload" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/11.150f24fc.js" as="script"><link rel="prefetch" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/10.167da0cc.js"><link rel="prefetch" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/12.a8595297.js"><link rel="prefetch" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/13.4fadf107.js"><link rel="prefetch" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/14.7a51874c.js"><link rel="prefetch" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/15.cceb53ed.js"><link rel="prefetch" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/16.62dc4f1a.js"><link rel="prefetch" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/3.45443b92.js"><link rel="prefetch" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/4.f6565c46.js"><link rel="prefetch" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/5.69222e9e.js"><link rel="prefetch" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/6.84619d7e.js"><link rel="prefetch" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/7.6e28b58c.js"><link rel="prefetch" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/8.cdb7835e.js"><link rel="prefetch" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/9.e5057ebc.js">
    <link rel="stylesheet" href="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/css/0.styles.a9148fe0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/LGTJ_YBLSS_WSYMYSJ_ZH/" class="home-link router-link-active"><!----> <span class="site-name">舒克张的个人博客</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/" class="nav-link router-link-active">技术</a></div><div class="nav-item"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/read/" class="nav-link">创作与共享</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/" class="nav-link router-link-active">技术</a></div><div class="nav-item"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/read/" class="nav-link">创作与共享</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/PACK.html" class="sidebar-link">打包工具</a></li><li><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Vue.js-1.html" class="active sidebar-link">Vue源码解析（1）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Vue.js-1.html#compiler" class="sidebar-link">compiler</a></li><li class="sidebar-sub-header"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Vue.js-1.html#core" class="sidebar-link">core</a></li><li class="sidebar-sub-header"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Vue.js-1.html#platform" class="sidebar-link">platform</a></li><li class="sidebar-sub-header"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Vue.js-1.html#server" class="sidebar-link">server</a></li><li class="sidebar-sub-header"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Vue.js-1.html#sfc" class="sidebar-link">sfc</a></li><li class="sidebar-sub-header"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Vue.js-1.html#shared" class="sidebar-link">shared</a></li><li class="sidebar-sub-header"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Vue.js-1.html#initglobalapi" class="sidebar-link">initGlobalApI</a></li><li class="sidebar-sub-header"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Vue.js-1.html#new-vue-的过程发生了什么" class="sidebar-link">new Vue 的过程发生了什么</a></li><li class="sidebar-sub-header"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Vue.js-1.html#render方法" class="sidebar-link">render方法</a></li><li class="sidebar-sub-header"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Vue.js-1.html#虚拟节点" class="sidebar-link">虚拟节点</a></li><li class="sidebar-sub-header"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Vue.js-1.html#vnode的产生" class="sidebar-link">VNode的产生</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Vue.js-1.html#children规范化" class="sidebar-link">children规范化</a></li><li class="sidebar-sub-header"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Vue.js-1.html#虚拟节点的创建" class="sidebar-link">虚拟节点的创建</a></li></ul></li></ul></li><li><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Grid.html" class="sidebar-link">grid布局</a></li><li><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/PHP-array2string.html" class="sidebar-link">PHP-将数组拼接成字符串</a></li><li><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/PHP-timeFunction.html" class="sidebar-link">php处理时间的函数-time/date</a></li><li><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/nodejs_statend.html" class="sidebar-link">koa基础</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="为什么分析vue源码"><a href="#为什么分析vue源码" class="header-anchor">#</a> 为什么分析Vue源码</h1> <p><code>javascripty</code>一门不太容易进阶的语言，我们通过学习一门优秀的框架源码能够帮助我们加深对语言的理解，同时在学习一门优秀框架的同时，收获的很有远甚于语言和框架原理本身设计模式，算法，底层交互实现细节方面的东西。</p> <h1 id="vue-js源码目录设计"><a href="#vue-js源码目录设计" class="header-anchor">#</a> Vue.js源码目录设计</h1> <div class="language-javascript extra-class"><pre class="language-javascript"><code>src
 ├── compiler # 编译相关 
 ├── core # 核心代码 
 ├── platforms # 不同平台的支持 
 ├── server # 服务端渲染 
 ├── sfc # <span class="token punctuation">.</span>vue 文件解析 
 ├── shared # 共享代码
</code></pre></div><h2 id="compiler"><a href="#compiler" class="header-anchor">#</a> compiler</h2> <p><code>compiler</code>目录包括<code>Vue.js</code>所有编译相关的代码。包括：</p> <ul><li>模板解析成 <code>AST</code> 树</li> <li><code>AST</code> 树优化</li> <li>代码生成</li></ul> <p>等功能。编译的工作可以在<strong>构建</strong>时做（借助webpack,vue-loader等辅助插件），也可以在运行时做，使用包含构建功能的<code>Vue.js</code>，显然，编译是一件好性能的工作，所以更推荐前者 —— 离线编译。</p> <h2 id="core"><a href="#core" class="header-anchor">#</a> core</h2> <p><code>core</code>目录包含了<code>Vue.js</code>的核心代码，包括:</p> <ul><li>内置组件</li> <li>全局<code>API</code>封装</li> <li><code>Vue</code> 实例化</li> <li>观察者</li> <li>虚拟<code>DOM</code></li> <li>工具函数等</li></ul> <p>这里的代码时<code>Vue.js</code>的灵魂。</p> <h2 id="platform"><a href="#platform" class="header-anchor">#</a> platform</h2> <p>Vue.js 是一个跨平台的 MVVM 框架，他可以泡在web上，也可以配合<code>weex</code>泡在 <code>native</code> 客户端上。<code>platform</code>是<code>Vue.js</code>的入口，2个目录代表2个主要入口。分别打包成不同平台运行的<code>Vue.js</code>.</p> <h2 id="server"><a href="#server" class="header-anchor">#</a> server</h2> <p><code>Vue.js</code> 2.0 支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。注意：<strong>这段代码是泡在服务端的<code>Node.js</code>,不要和泡在浏览器端的<code>Vue.js</code>混为一谈。</strong></p> <h2 id="sfc"><a href="#sfc" class="header-anchor">#</a> sfc</h2> <p>通常我们开发 <code>Vue.js</code> 都会借助 <code>webpack</code> 构造，然后通过 <code>.vue</code> 单文件来编写组件。
这个目录下的代码逻辑会把<code>.vue</code>文件解析成为一个 <code>javascript</code> 的对象。</p> <h2 id="shared"><a href="#shared" class="header-anchor">#</a> shared</h2> <p><code>Vue.js</code> 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的<code>Vue.js</code>和服务器端的<code>Vue.js</code>所共享的。</p> <h1 id="vue入口"><a href="#vue入口" class="header-anchor">#</a> Vue入口</h1> <p><code>Vue</code> 类的定义是在 <code>src/core/index.js</code> 中，是以<code>Function</code>实现额类，我们只能通过<code>new Vue</code> 去实例化它。</p> <ul><li>有些同学可能会问：<strong>为何<code>Vue</code>类不用<code>ES6</code>的<code>Class</code>去实现呢？</strong>，我们往后看这里有很多的<code>xxxMixin</code>的函数调用，并把<code>Vue</code>当参数传入，他们的作用是给<code>Vue</code>的<code>prototype</code>上扩展一些方法，<code>Vue</code>按照功能把这些扩展分散到多个模块中去详细实现，这么做其实是站在可维护的角度去考虑的。</li></ul> <h2 id="initglobalapi"><a href="#initglobalapi" class="header-anchor">#</a> initGlobalApI</h2> <p><code>Vue.js</code> 在整个初始化过程中，会同时向它的原型上和对象本身扩展全局静态方法，它的定义在src/core/global-api/index.js中。</p> <blockquote><p>行文至此，读者应该已经了解了Vue.js初始化的过程和原理，对Vue有了一个直观的感觉。大家加油！</p></blockquote> <h1 id="数据驱动"><a href="#数据驱动" class="header-anchor">#</a> 数据驱动</h1> <p>Vue.js 一个核心思想是数据驱动，所谓的数据驱动是指：视图是有数据驱动展示的，我们对视图的修改，不会直接操作DOM,而是通过修改数据。它相对于传统的前端开发，比如使用jQuery等前端库直接修改DOM，大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让逻辑变得非常清晰，因为DOM变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用触碰DOM,这样的代码非常利于维护。</p> <p>在Vue.js我们最常见的是采用简单的模板语法来声明式的将数据渲染为DOM</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// template</span>
<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
  <span class="token punctuation">{</span><span class="token punctuation">{</span> message <span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span> el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span> data<span class="token punctuation">:</span> <span class="token punctuation">{</span> message<span class="token punctuation">:</span> <span class="token string">'Hello Vue!'</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>最终它会在页面上渲染出“hello Vue!”,接下来我们看一下模板和数据最终如何渲染成为DOM。</p> <h2 id="new-vue-的过程发生了什么"><a href="#new-vue-的过程发生了什么" class="header-anchor">#</a> new Vue 的过程发生了什么</h2> <p>从入口代码开始分析，我们先来分析new Vue背后发生了那些事情。我们都知道，new 关键字在javascript语言中代表实例化是一个对象，而Vue实际上就是一个类。类在JavaScript中使用Function来实现的，来看一下源码，在src/core/instance/index.js中:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Vue</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Vue</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'Vue is a constructor and should be called with the `new` keyword'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到Vue只能通过new关键字初始化，在构造函数中会进行this._init，该方法在src/core/instance/init.js中定义。
在进行this._init的过程中，会进行以下操作：</p> <ul><li>合并配置项</li> <li>初始化生命周期</li> <li>初始化事件中心</li> <li>初始化渲染</li></ul> <blockquote><p>以上四件事是在生命周期钩子'beforeCreate'之前做的;</p></blockquote> <ul><li>解析注入</li> <li>初始化'data,props,computed,watcher'</li> <li>解析提供者</li></ul> <blockquote><p>以上三件是是在生命周期钩子'created'之前做的;</p></blockquote> <p>所有的这些逻辑都在this._init中以单个文件的形式运行，使得主线逻辑一目了然。到目前为止，Vue生命周期也走到了'created',但是这个时候只是初始化了项目，这个时候我们在页面上还看不到任何变化，但是在程序内部已经可以拿到data,props数据了。</p> <p>我们沿着主线继续走，在初始化的最后，检测到如果有el属性，则调用vm.$mount方法挂载vm,挂载是为了把模板渲染成最终的DOM。整个挂载过程会伴随着挂载前的优化，挂载函数的执行，render函数执行生成虚拟节点，最终调用_update更新DOM。</p> <h1 id="vue-实例挂载的实现"><a href="#vue-实例挂载的实现" class="header-anchor">#</a> Vue 实例挂载的实现</h1> <blockquote><p>在上一节讲解new Vue()过程的时候，我们已经知道了，这个过程会触发'beforeCreate'和'created'这两个钩子函数，同时在不同的时期做了一些初始化工作，虽然我们还不能看到页面上有任何变化，但是我们已经可以获取到data和props这些数据了。同时提到我们在各种init之后也就是this._init函数的最后，会检测是否存在options.el，如果存在，实例就会调用$mount函数去挂载DOM,也就是把我们写的页面和数据结合起来生成一个页面;</p></blockquote> <p>本节我们会分析一下这个$mount是个什么过程;</p> <p>Vue中我们是通过是通过$mount去挂载vm的，$mount方法在不同的文件中被定义了很多次，这些其实都是基于不同平台的重载，因为$mount的实现和平台以及构建方式都有关系。</p> <p>我们先重点分析带<code>compiler</code>版本的实现，这是一个运行时构建方法，这个过程抛开了webpack的vue-loader,也就是裸奔在浏览器上，这样我们通过调试可以更清晰的理解原理。</p> <p><code>compiler</code>版本的<code>$mount</code>实现文件是<code>src/platform/web/entry-runtime-with-compiler.js</code>
首先会使用一个<code>mount</code>变量缓存原型上的<code>$mount</code>方法，接着重新定义该方法，也就是'重载抽象方法',在这个新的<code>$mount</code>方法中执行流程如下：</p> <ul><li><p>首先会对<code>el</code>做限制，不能挂载在<code>body</code>和<code>html</code>上。如果你真的这么干了，Vue会对你发出警告<code>Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.</code>。</p></li> <li><p>检测是否定义了<code>render</code>方法，如果没有，就会把el或者template字符串转换成<code>render</code>方法。</p></li></ul> <blockquote><p>这个<code>render</code>方法就是我们在new Vue()的时候可以写的<code>render</code>函数。将<code>el</code>和<code>template</code>转换成<code>render</code>需要调用<code>compileToFunctions</code>函数实现。</p></blockquote> <ul><li>做完这些后，就会调用之前缓存的原型上的<code>$mount</code>也就是<code>mount</code>变量实现挂载。</li></ul> <blockquote><p>这其实相当于在<code>$mount</code>方法之外加了一层处理逻辑，之所以写成这种形式可能是为了使框架的使用更加优雅。</p></blockquote> <p>继续沿着主线走，我们已经知道了调用<code>$mount</code>时会先将<code>$mount</code>缓存到<code>mount</code>，为了不至于被这两个名字搞混，读者可以先缓一下想一想<code>mount</code>和<code>$mount</code>之间的关系，这两者有分别承担着什么责任，分别作了什么事情。</p> <p>行文至此，我们还不知道真正的<code>$mount</code>是怎么回事，接下来我们就分析一波。这个函数定义在 src/platform/web/runtime/index.js 文件，之所以这么设计之前已经讲过了，就是为了能够复用，这样的<code>$mount</code>方法是可以被<code>runtime only</code>版本的<code>Vue</code>直接使用的。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$mount</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>
  <span class="token parameter">el<span class="token operator">?</span><span class="token punctuation">:</span> string<span class="token operator">|</span>Element<span class="token punctuation">,</span>
  hydrating<span class="token operator">?</span><span class="token punctuation">:</span>boolean</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span>Component <span class="token punctuation">{</span>
  el <span class="token operator">=</span> el <span class="token operator">&amp;&amp;</span> inBrowser<span class="token operator">?</span> <span class="token function">query</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">undefined</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>el<span class="token punctuation">,</span>hydrating<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>$mount</code>方法支持传入两个参数</p> <ul><li>第一个是<code>el</code>他表示挂载的元素;</li></ul> <blockquote><p>挂载的元素可以是字符串也可以是DOM对象。如果传的是字符串，在浏览器环境下会调用<code>query</code>方法转换成DOM对象。</p></blockquote> <ul><li>第二个参数是和服务器渲染相关，我们先不关心它。</li></ul> <blockquote><p>在浏览器环境下我们也不需要传这个参数。</p></blockquote> <p>我们已经看到，实际上<code>$mount</code>只是简单的处理了一下传入的<code>el</code>对象，就把它安排到<code>mountComponent</code>里面去处理了。（可见<code>$mount</code>地位真的很高，前面有人帮他当替身，后面累活都交给别人做）。</p> <p>我们看一看这个定义在src/core/instance/lifecycle.js中的<code>mountComponent</code>究竟干了些什么。</p> <ul><li>检测一下配置项哟没有<code>render</code>函数，没有的话就会进行一些提醒<code>render</code>函数不存在。</li> <li>调用生命周期钩子<code>beforeMount</code>。</li> <li>定义<code>updateComponent</code>方法。</li></ul> <blockquote><p>在这个方法里面会调用<code>_render</code>生成VNode,最终调用<code>_update</code>方法去实现DOM渲染。</p></blockquote> <ul><li>实例化<code>Watcher</code>，用来监听渲染。</li></ul> <blockquote><p><code>Watchler</code>主要功能就是执行回调函数<code>updateComponent</code>进行DOM渲染。这个过程发生在初始化和vm实例中的数据发生变化的时候。</p></blockquote> <ul><li>最后，如果当前处在根节点，就把<code>vm._isMounted</code>设置为<code>true</code>,表示这个实例已经挂载了，同时执行<code>mounted</code>钩子函数。</li></ul> <h2 id="render方法"><a href="#render方法" class="header-anchor">#</a> render方法</h2> <p>Vue 的<code>_render</code>方法是实例的一个私有方法，它用来把实例渲染成一个虚拟Node。定义在src/core/instance/render.js文件中。</p> <p>在这个函数中，最重要的就是<code>render</code>方法的调用，我们在平时开发的过程中，手写<code>render</code>方法的地方比较少，而手写最多的就是<code>template</code>模板，在之前的<code>mounted</code>方法的实现中，会把<code>template</code>编译成为<code>render</code>方法。</p> <p>在这里，我们又遇到了一个<code>_render</code>和<code>render</code>，读者要注意不能弄混它们。</p> <p>熟悉Vue使用的小伙伴应该知道，<code>render</code>函数的第一个参数是<code>createElement</code>。我们写好的的<code>render</code>函数会在<code>_render</code>方法中被调用。我们写的<code>createElement</code>方法具体传到Vue内部是怎么实现的呢？事实上他是在调用<code>initRender</code>的时候被动态的声明，和它一起声明的还有<code>_c</code>，他们两个功能一样，区别在于一个是处理内部编译的模板，一个是处理用户手写的渲染方法。</p> <h2 id="虚拟节点"><a href="#虚拟节点" class="header-anchor">#</a> 虚拟节点</h2> <p><code>vm._render</code>是调用<code>createElement</code>生成了<code>vnode</code>，他是一个虚拟<code>node</code>,我们要看看<code>createElement</code>具体实现，在这之前我们需要先了解一下什么是虚拟DOM。</p> <p>首先我们肯定都知道什么是DOM,文档对象模型,他是用来描述一个文档内容和结构的抽象标准，提供了相当多的接口供我们实现具体对文档内容和结构的操作。如果我们打开浏览器输出一下一个DOM对象的内容，可以发现他是非常庞大的，因为浏览器的标准把DOM设计的十分复杂，所以当我们去更新一个DOM元素的时候，会产生一定的性能问题。</p> <p>为了是我们的框架能够拥有更高的性能，Vue引入了Virtual DOM概念。将原生DOM抽象为一个简单的对象，内容上不必完全重现DOM,只要提供核心的Vue用的到的概念就可以，这就比创建一个真实DOM代价小得多。</p> <p>在Vue.js中，Virtual DOM使用<code>VNode</code>这么一个<code>class</code>去秒速的，他定义在src/core/vdom/vnode.js中。</p> <p>通过阅读源码我们可以看到，VNode的内容比真实DOM要少得多，但是同时他也会富含一些Vue需要的特别的特性，在生成一个VNode实例之后，想要渲染成真实DOM实际上需要经历<code>create</code>,<code>diff</code>,<code>patch</code>等过程。<code>createElement</code>就是产生VNode的函数。</p> <h2 id="vnode的产生"><a href="#vnode的产生" class="header-anchor">#</a> VNode的产生</h2> <p>Vue.js 是使用<code>createElement</code>方法创建VNode的，定义在src/core/vnode/create-element.js中，它实际上是对_createElement方法的一层封装，它允许入参更加灵活，在处理完这些参数后，调用真实的<code>_createElement</code>真正创建<code>VNode</code>。</p> <p><code>_createElement</code>方法有5个参数</p> <ul><li>context 表示VNode的上下文环境，他是Component类型。</li> <li>tag 表示标签，他可以是字符串或者component。</li> <li>data 表示一个VNode数据，他是一个VNodeData，定义在flow/vnode.js中。</li> <li>children 当前Vnode的子节点，他是任意类型的，它接下来需要被规范为标准的VNode数组。</li> <li>normalizationType 子节点规范的类型，类型不同规范的方法也不一样，他主要是依据render函数是编译生成的还是用户手写的。</li></ul> <p>虽然<code>createElement</code>函数流程有些复杂，但是我们可以把它重点分析为<code>children</code>规范化和<code>VNode</code>创建俩部分。</p> <h3 id="children规范化"><a href="#children规范化" class="header-anchor">#</a> children规范化</h3> <p>由于Virtual DOM实际上是一个树状结构，每一个<code>VNode</code>可能会有多个子节点，这些子节点应该也是<code>VNode</code>类型。<code>_createElement</code>接受的第4个入参是任意类型，因此我们需要把它规范成为一个VNode类型。</p> <p>这里根据<code>normalizationType</code>的差别，调用了<code>normalizeChildren(children)</code>和<code>simpleNormalizeChildren(children)</code>方法，他们的定义都在src/core/vdom/helpers/normalizieChildren.js```中。</p> <p>根据注释我们知道这两个函数调用的不同：</p> <ul><li><p><code>simpleNormalizeChildren</code>方法调用场景是<code>render</code>函数是编译生成的。理论上编译生成的<code>children</code>已经是Vnode类型，但是有一个例外的情况<code>functional component</code>函数式组件返回的是一个数组而不是一个节点,所以会通过<code>Array.prototype.concat</code>方法把整个<code>children</code>数组变成一个一维数组。</p></li> <li><p><code>normalizieChildren</code>方法的调用场景有两种。一个场景是<code>render</code>函数是用户手写的，当<code>children</code>只有一个节点的时候，Vue.js 从接口层面允许用户把<code>children</code>写成基础类型创建简单的文本节点，这种情况会调用createTextVNode生成一个文本节点的VNode;另一个场景是当编译<code>slot</code>,<code>v-for</code>时会产生嵌套数组的情况，会调用<code>normalizeArrayChildren</code>方法。</p></li></ul> <blockquote><p><code>normalizeArrayChildren</code>方法接受2个入参；<code>children</code>表示需要规范的子节点，<code>nestedIndex</code>表示嵌套的索引，因为单个<code>child</code>可能是一个数组类型。<code>normalizeArrayChildren</code>主要的逻辑就是遍历<code>children</code>,获得单个节点<code>c</code>,然后对<code>c</code>的类型判断，如果是一个数组类型，就递归处理；如果是基础类型，就通过<code>createTextVNode</code>方法转换成VNode类型；最后，如果两种都不是，就已经是VNode类型的了，如果<code>children</code>是一个列表并且列表还存在嵌套的情况，就会根据<code>nestIndex</code>去更新他的<code>key</code>。这里需要注意，这三种情况中的text节点如果有两个连续的，就会合并成一个。</p></blockquote> <p>通过对children的规范化，children变成了一个类型的VNode的Array.</p> <h3 id="虚拟节点的创建"><a href="#虚拟节点的创建" class="header-anchor">#</a> 虚拟节点的创建</h3> <p>回到<code>createElement</code>函数，规范化children之后，接下来会创建一个VNode。</p> <p>创建VNode时，会先对tag做判断</p> <ul><li>如果是string，则接着判断如果是内置的一些节点，则直接创建一个普通VNode。如果是已经创建的组件名，就会调用createElement创建一个组件类型的Vnode节点。否则创建未知的标签VNode。</li> <li>tag是一个Component类型，则直接调用CreateComponent创建组件类型的VNode。</li></ul> <h1 id="update"><a href="#update" class="header-anchor">#</a> update</h1> <p>我们已经深入了好几层了，让我们做个总结，以避免有些同学迷路了。</p> <p>通过前面的分析，我们了解了，new Vue之后会调用_init方法进行初始化工作，这个过程会合并配置，初始化生命周期，初始化事件中心，初始化渲染，调用beforeCreate钩子，初始化data等数据，创建监听，执行created钩子。</p> <p>初始化之后回调用vm.$mount方法挂载DOM,在挂载的时候回执行_render生成虚拟DOM和_update渲染DOM。</p> <p>在执行_render的时候会调用_createElement方法实际生成VNode,这个过程会进行children的规范化一节VNode最终生成。</p> <p>我们发现，整个$mount方法实际上到现在为止还没结束。</p> <p>接下来，我们分析一下，虚拟DOM是如何一步步变成页面的。</p> <p>Vue.js的_update是实例的私有方法，他被调用时机有2个：首次渲染，数据更新。</p> <p>我们在这一章节只分析首次渲染部分。</p> <p>_update方法吧VNode渲染为真实DOM,它定义在src/core/instance/lifecycle.js中。</p> <p>_update的核心就是调用vm.__patch__方法，这个方法是因平台而异的。在web平台中，他的定义在src/platforms/web/runtime/index.js中。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__patch__ <span class="token operator">=</span> inBrowser <span class="token operator">?</span> patch <span class="token punctuation">:</span> noop<span class="token punctuation">;</span>
</code></pre></div><p>可以看出，在web平台上，是否是服务端渲染也会产生影响。在服务端渲染中，没有真实的浏览器DOM环境，所以不需要把VNode最终转换成DOM,因此是一个空函数。在浏览器渲染中，它指向了patch方法，这个方法定义runtime/patch.js中。</p> <p>该方法调用了<code>createPatchFunction</code>方法的返回值，这里传入了一个对象，包含<code>nodeOps</code>参数和<code>modules</code>参数。其中，<code>nodeOps</code>定义了一些DOM方法，<code>modules</code>定义了一些模块的钩子函数实现，它定义在src/core/vdom/patch.js中。</p> <p><code>createFatchFunction</code>定义了一系列辅助方法，最终返回了<code>patch</code>函数，这个方法就赋值给了<code>vm._update</code>函数里调用的<code>vm.__patch__</code>。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">编辑日期:</span> <span class="time">12/30/2019, 12:42:54 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/PACK.html" class="prev">打包工具</a></span> <span class="next"><a href="/LGTJ_YBLSS_WSYMYSJ_ZH/knowledge/FE/Grid.html">grid布局</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/app.c54d493b.js" defer></script><script src="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/2.6219b60a.js" defer></script><script src="/LGTJ_YBLSS_WSYMYSJ_ZH/assets/js/11.150f24fc.js" defer></script>
  </body>
</html>
