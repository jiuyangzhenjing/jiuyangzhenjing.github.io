(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{213:function(e,t,v){"use strict";v.r(t);var _=v(0),a=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"为什么分析vue源码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么分析vue源码"}},[e._v("#")]),e._v(" 为什么分析Vue源码")]),e._v(" "),v("p",[v("code",[e._v("javascripty")]),e._v("一门不太容易进阶的语言，我们通过学习一门优秀的框架源码能够帮助我们加深对语言的理解，同时在学习一门优秀框架的同时，收获的很有远甚于语言和框架原理本身设计模式，算法，底层交互实现细节方面的东西。")]),e._v(" "),v("h1",{attrs:{id:"vue-js源码目录设计"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-js源码目录设计"}},[e._v("#")]),e._v(" Vue.js源码目录设计")]),e._v(" "),v("div",{staticClass:"language-javascript extra-class"},[v("pre",{pre:!0,attrs:{class:"language-javascript"}},[v("code",[e._v("src\n ├── compiler # 编译相关 \n ├── core # 核心代码 \n ├── platforms # 不同平台的支持 \n ├── server # 服务端渲染 \n ├── sfc # "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("vue 文件解析 \n ├── shared # 共享代码\n")])])]),v("h2",{attrs:{id:"compiler"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#compiler"}},[e._v("#")]),e._v(" compiler")]),e._v(" "),v("p",[v("code",[e._v("compiler")]),e._v("目录包括"),v("code",[e._v("Vue.js")]),e._v("所有编译相关的代码。包括：")]),e._v(" "),v("ul",[v("li",[e._v("模板解析成 "),v("code",[e._v("AST")]),e._v(" 树")]),e._v(" "),v("li",[v("code",[e._v("AST")]),e._v(" 树优化")]),e._v(" "),v("li",[e._v("代码生成")])]),e._v(" "),v("p",[e._v("等功能。编译的工作可以在"),v("strong",[e._v("构建")]),e._v("时做（借助webpack,vue-loader等辅助插件），也可以在运行时做，使用包含构建功能的"),v("code",[e._v("Vue.js")]),e._v("，显然，编译是一件好性能的工作，所以更推荐前者 —— 离线编译。")]),e._v(" "),v("h2",{attrs:{id:"core"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#core"}},[e._v("#")]),e._v(" core")]),e._v(" "),v("p",[v("code",[e._v("core")]),e._v("目录包含了"),v("code",[e._v("Vue.js")]),e._v("的核心代码，包括:")]),e._v(" "),v("ul",[v("li",[e._v("内置组件")]),e._v(" "),v("li",[e._v("全局"),v("code",[e._v("API")]),e._v("封装")]),e._v(" "),v("li",[v("code",[e._v("Vue")]),e._v(" 实例化")]),e._v(" "),v("li",[e._v("观察者")]),e._v(" "),v("li",[e._v("虚拟"),v("code",[e._v("DOM")])]),e._v(" "),v("li",[e._v("工具函数等")])]),e._v(" "),v("p",[e._v("这里的代码时"),v("code",[e._v("Vue.js")]),e._v("的灵魂。")]),e._v(" "),v("h2",{attrs:{id:"platform"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#platform"}},[e._v("#")]),e._v(" platform")]),e._v(" "),v("p",[e._v("Vue.js 是一个跨平台的 MVVM 框架，他可以泡在web上，也可以配合"),v("code",[e._v("weex")]),e._v("泡在 "),v("code",[e._v("native")]),e._v(" 客户端上。"),v("code",[e._v("platform")]),e._v("是"),v("code",[e._v("Vue.js")]),e._v("的入口，2个目录代表2个主要入口。分别打包成不同平台运行的"),v("code",[e._v("Vue.js")]),e._v(".")]),e._v(" "),v("h2",{attrs:{id:"server"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#server"}},[e._v("#")]),e._v(" server")]),e._v(" "),v("p",[v("code",[e._v("Vue.js")]),e._v(" 2.0 支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。注意："),v("strong",[e._v("这段代码是泡在服务端的"),v("code",[e._v("Node.js")]),e._v(",不要和泡在浏览器端的"),v("code",[e._v("Vue.js")]),e._v("混为一谈。")])]),e._v(" "),v("h2",{attrs:{id:"sfc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sfc"}},[e._v("#")]),e._v(" sfc")]),e._v(" "),v("p",[e._v("通常我们开发 "),v("code",[e._v("Vue.js")]),e._v(" 都会借助 "),v("code",[e._v("webpack")]),e._v(" 构造，然后通过 "),v("code",[e._v(".vue")]),e._v(" 单文件来编写组件。\n这个目录下的代码逻辑会把"),v("code",[e._v(".vue")]),e._v("文件解析成为一个 "),v("code",[e._v("javascript")]),e._v(" 的对象。")]),e._v(" "),v("h2",{attrs:{id:"shared"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#shared"}},[e._v("#")]),e._v(" shared")]),e._v(" "),v("p",[v("code",[e._v("Vue.js")]),e._v(" 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的"),v("code",[e._v("Vue.js")]),e._v("和服务器端的"),v("code",[e._v("Vue.js")]),e._v("所共享的。")]),e._v(" "),v("h1",{attrs:{id:"vue入口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue入口"}},[e._v("#")]),e._v(" Vue入口")]),e._v(" "),v("p",[v("code",[e._v("Vue")]),e._v(" 类的定义是在 "),v("code",[e._v("src/core/index.js")]),e._v(" 中，是以"),v("code",[e._v("Function")]),e._v("实现额类，我们只能通过"),v("code",[e._v("new Vue")]),e._v(" 去实例化它。")]),e._v(" "),v("ul",[v("li",[e._v("有些同学可能会问："),v("strong",[e._v("为何"),v("code",[e._v("Vue")]),e._v("类不用"),v("code",[e._v("ES6")]),e._v("的"),v("code",[e._v("Class")]),e._v("去实现呢？")]),e._v("，我们往后看这里有很多的"),v("code",[e._v("xxxMixin")]),e._v("的函数调用，并把"),v("code",[e._v("Vue")]),e._v("当参数传入，他们的作用是给"),v("code",[e._v("Vue")]),e._v("的"),v("code",[e._v("prototype")]),e._v("上扩展一些方法，"),v("code",[e._v("Vue")]),e._v("按照功能把这些扩展分散到多个模块中去详细实现，这么做其实是站在可维护的角度去考虑的。")])]),e._v(" "),v("h2",{attrs:{id:"initglobalapi"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#initglobalapi"}},[e._v("#")]),e._v(" initGlobalApI")]),e._v(" "),v("p",[v("code",[e._v("Vue.js")]),e._v(" 在整个初始化过程中，会同时向它的原型上和对象本身扩展全局静态方法，它的定义在src/core/global-api/index.js中。")]),e._v(" "),v("blockquote",[v("p",[e._v("行文至此，读者应该已经了解了Vue.js初始化的过程和原理，对Vue有了一个直观的感觉。大家加油！")])]),e._v(" "),v("h1",{attrs:{id:"数据驱动"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据驱动"}},[e._v("#")]),e._v(" 数据驱动")]),e._v(" "),v("p",[e._v("Vue.js 一个核心思想是数据驱动，所谓的数据驱动是指：视图是有数据驱动展示的，我们对视图的修改，不会直接操作DOM,而是通过修改数据。它相对于传统的前端开发，比如使用jQuery等前端库直接修改DOM，大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让逻辑变得非常清晰，因为DOM变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用触碰DOM,这样的代码非常利于维护。")]),e._v(" "),v("p",[e._v("在Vue.js我们最常见的是采用简单的模板语法来声明式的将数据渲染为DOM")]),e._v(" "),v("div",{staticClass:"language-javascript extra-class"},[v("pre",{pre:!0,attrs:{class:"language-javascript"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// template")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("div id"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),v("span",{pre:!0,attrs:{class:"token string"}},[e._v('"app"')]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n  "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" message "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),e._v("div"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n")])])]),v("div",{staticClass:"language-javascript extra-class"},[v("pre",{pre:!0,attrs:{class:"language-javascript"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" app "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Vue")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[e._v("'#app'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" data"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" message"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[e._v("'Hello Vue!'")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),v("p",[e._v("最终它会在页面上渲染出“hello Vue!”,接下来我们看一下模板和数据最终如何渲染成为DOM。")]),e._v(" "),v("h2",{attrs:{id:"new-vue-的过程发生了什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#new-vue-的过程发生了什么"}},[e._v("#")]),e._v(" new Vue 的过程发生了什么")]),e._v(" "),v("p",[e._v("从入口代码开始分析，我们先来分析new Vue背后发生了那些事情。我们都知道，new 关键字在javascript语言中代表实例化是一个对象，而Vue实际上就是一个类。类在JavaScript中使用Function来实现的，来看一下源码，在src/core/instance/index.js中:")]),e._v(" "),v("div",{staticClass:"language-javascript extra-class"},[v("pre",{pre:!0,attrs:{class:"language-javascript"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("Vue")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("options")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("process"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("env"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token constant"}},[e._v("NODE_ENV")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("!==")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[e._v("'production'")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&&")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("!")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("instanceof")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Vue")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("warn")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[e._v("'Vue is a constructor and should be called with the `new` keyword'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("_init")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("options"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),v("p",[e._v("可以看到Vue只能通过new关键字初始化，在构造函数中会进行this._init，该方法在src/core/instance/init.js中定义。\n在进行this._init的过程中，会进行以下操作：")]),e._v(" "),v("ul",[v("li",[e._v("合并配置项")]),e._v(" "),v("li",[e._v("初始化生命周期")]),e._v(" "),v("li",[e._v("初始化事件中心")]),e._v(" "),v("li",[e._v("初始化渲染")])]),e._v(" "),v("blockquote",[v("p",[e._v("以上四件事是在生命周期钩子'beforeCreate'之前做的;")])]),e._v(" "),v("ul",[v("li",[e._v("解析注入")]),e._v(" "),v("li",[e._v("初始化'data,props,computed,watcher'")]),e._v(" "),v("li",[e._v("解析提供者")])]),e._v(" "),v("blockquote",[v("p",[e._v("以上三件是是在生命周期钩子'created'之前做的;")])]),e._v(" "),v("p",[e._v("所有的这些逻辑都在this._init中以单个文件的形式运行，使得主线逻辑一目了然。到目前为止，Vue生命周期也走到了'created',但是这个时候只是初始化了项目，这个时候我们在页面上还看不到任何变化，但是在程序内部已经可以拿到data,props数据了。")]),e._v(" "),v("p",[e._v("我们沿着主线继续走，在初始化的最后，检测到如果有el属性，则调用vm.$mount方法挂载vm,挂载是为了把模板渲染成最终的DOM。整个挂载过程会伴随着挂载前的优化，挂载函数的执行，render函数执行生成虚拟节点，最终调用_update更新DOM。")]),e._v(" "),v("h1",{attrs:{id:"vue-实例挂载的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-实例挂载的实现"}},[e._v("#")]),e._v(" Vue 实例挂载的实现")]),e._v(" "),v("blockquote",[v("p",[e._v("在上一节讲解new Vue()过程的时候，我们已经知道了，这个过程会触发'beforeCreate'和'created'这两个钩子函数，同时在不同的时期做了一些初始化工作，虽然我们还不能看到页面上有任何变化，但是我们已经可以获取到data和props这些数据了。同时提到我们在各种init之后也就是this._init函数的最后，会检测是否存在options.el，如果存在，实例就会调用$mount函数去挂载DOM,也就是把我们写的页面和数据结合起来生成一个页面;")])]),e._v(" "),v("p",[e._v("本节我们会分析一下这个$mount是个什么过程;")]),e._v(" "),v("p",[e._v("Vue中我们是通过是通过$mount去挂载vm的，$mount方法在不同的文件中被定义了很多次，这些其实都是基于不同平台的重载，因为$mount的实现和平台以及构建方式都有关系。")]),e._v(" "),v("p",[e._v("我们先重点分析带"),v("code",[e._v("compiler")]),e._v("版本的实现，这是一个运行时构建方法，这个过程抛开了webpack的vue-loader,也就是裸奔在浏览器上，这样我们通过调试可以更清晰的理解原理。")]),e._v(" "),v("p",[v("code",[e._v("compiler")]),e._v("版本的"),v("code",[e._v("$mount")]),e._v("实现文件是"),v("code",[e._v("src/platform/web/entry-runtime-with-compiler.js")]),e._v("\n首先会使用一个"),v("code",[e._v("mount")]),e._v("变量缓存原型上的"),v("code",[e._v("$mount")]),e._v("方法，接着重新定义该方法，也就是'重载抽象方法',在这个新的"),v("code",[e._v("$mount")]),e._v("方法中执行流程如下：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("首先会对"),v("code",[e._v("el")]),e._v("做限制，不能挂载在"),v("code",[e._v("body")]),e._v("和"),v("code",[e._v("html")]),e._v("上。如果你真的这么干了，Vue会对你发出警告"),v("code",[e._v("Do not mount Vue to <html> or <body> - mount to normal elements instead.")]),e._v("。")])]),e._v(" "),v("li",[v("p",[e._v("检测是否定义了"),v("code",[e._v("render")]),e._v("方法，如果没有，就会把el或者template字符串转换成"),v("code",[e._v("render")]),e._v("方法。")])])]),e._v(" "),v("blockquote",[v("p",[e._v("这个"),v("code",[e._v("render")]),e._v("方法就是我们在new Vue()的时候可以写的"),v("code",[e._v("render")]),e._v("函数。将"),v("code",[e._v("el")]),e._v("和"),v("code",[e._v("template")]),e._v("转换成"),v("code",[e._v("render")]),e._v("需要调用"),v("code",[e._v("compileToFunctions")]),e._v("函数实现。")])]),e._v(" "),v("ul",[v("li",[e._v("做完这些后，就会调用之前缓存的原型上的"),v("code",[e._v("$mount")]),e._v("也就是"),v("code",[e._v("mount")]),e._v("变量实现挂载。")])]),e._v(" "),v("blockquote",[v("p",[e._v("这其实相当于在"),v("code",[e._v("$mount")]),e._v("方法之外加了一层处理逻辑，之所以写成这种形式可能是为了使框架的使用更加优雅。")])]),e._v(" "),v("p",[e._v("继续沿着主线走，我们已经知道了调用"),v("code",[e._v("$mount")]),e._v("时会先将"),v("code",[e._v("$mount")]),e._v("缓存到"),v("code",[e._v("mount")]),e._v("，为了不至于被这两个名字搞混，读者可以先缓一下想一想"),v("code",[e._v("mount")]),e._v("和"),v("code",[e._v("$mount")]),e._v("之间的关系，这两者有分别承担着什么责任，分别作了什么事情。")]),e._v(" "),v("p",[e._v("行文至此，我们还不知道真正的"),v("code",[e._v("$mount")]),e._v("是怎么回事，接下来我们就分析一波。这个函数定义在 src/platform/web/runtime/index.js 文件，之所以这么设计之前已经讲过了，就是为了能够复用，这样的"),v("code",[e._v("$mount")]),e._v("方法是可以被"),v("code",[e._v("runtime only")]),e._v("版本的"),v("code",[e._v("Vue")]),e._v("直接使用的。")]),e._v(" "),v("div",{staticClass:"language-javascript extra-class"},[v("pre",{pre:!0,attrs:{class:"language-javascript"}},[v("code",[v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Vue")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("prototype"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("$mount")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("\n  "),v("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("el"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" string"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v("Element"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  hydrating"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("boolean")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("Component "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  el "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" el "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&&")]),e._v(" inBrowser"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("query")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("undefined")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("mountComponent")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("hydrating"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),v("p",[v("code",[e._v("$mount")]),e._v("方法支持传入两个参数")]),e._v(" "),v("ul",[v("li",[e._v("第一个是"),v("code",[e._v("el")]),e._v("他表示挂载的元素;")])]),e._v(" "),v("blockquote",[v("p",[e._v("挂载的元素可以是字符串也可以是DOM对象。如果传的是字符串，在浏览器环境下会调用"),v("code",[e._v("query")]),e._v("方法转换成DOM对象。")])]),e._v(" "),v("ul",[v("li",[e._v("第二个参数是和服务器渲染相关，我们先不关心它。")])]),e._v(" "),v("blockquote",[v("p",[e._v("在浏览器环境下我们也不需要传这个参数。")])]),e._v(" "),v("p",[e._v("我们已经看到，实际上"),v("code",[e._v("$mount")]),e._v("只是简单的处理了一下传入的"),v("code",[e._v("el")]),e._v("对象，就把它安排到"),v("code",[e._v("mountComponent")]),e._v("里面去处理了。（可见"),v("code",[e._v("$mount")]),e._v("地位真的很高，前面有人帮他当替身，后面累活都交给别人做）。")]),e._v(" "),v("p",[e._v("我们看一看这个定义在src/core/instance/lifecycle.js中的"),v("code",[e._v("mountComponent")]),e._v("究竟干了些什么。")]),e._v(" "),v("ul",[v("li",[e._v("检测一下配置项哟没有"),v("code",[e._v("render")]),e._v("函数，没有的话就会进行一些提醒"),v("code",[e._v("render")]),e._v("函数不存在。")]),e._v(" "),v("li",[e._v("调用生命周期钩子"),v("code",[e._v("beforeMount")]),e._v("。")]),e._v(" "),v("li",[e._v("定义"),v("code",[e._v("updateComponent")]),e._v("方法。")])]),e._v(" "),v("blockquote",[v("p",[e._v("在这个方法里面会调用"),v("code",[e._v("_render")]),e._v("生成VNode,最终调用"),v("code",[e._v("_update")]),e._v("方法去实现DOM渲染。")])]),e._v(" "),v("ul",[v("li",[e._v("实例化"),v("code",[e._v("Watcher")]),e._v("，用来监听渲染。")])]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("Watchler")]),e._v("主要功能就是执行回调函数"),v("code",[e._v("updateComponent")]),e._v("进行DOM渲染。这个过程发生在初始化和vm实例中的数据发生变化的时候。")])]),e._v(" "),v("ul",[v("li",[e._v("最后，如果当前处在根节点，就把"),v("code",[e._v("vm._isMounted")]),e._v("设置为"),v("code",[e._v("true")]),e._v(",表示这个实例已经挂载了，同时执行"),v("code",[e._v("mounted")]),e._v("钩子函数。")])]),e._v(" "),v("h2",{attrs:{id:"render方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#render方法"}},[e._v("#")]),e._v(" render方法")]),e._v(" "),v("p",[e._v("Vue 的"),v("code",[e._v("_render")]),e._v("方法是实例的一个私有方法，它用来把实例渲染成一个虚拟Node。定义在src/core/instance/render.js文件中。")]),e._v(" "),v("p",[e._v("在这个函数中，最重要的就是"),v("code",[e._v("render")]),e._v("方法的调用，我们在平时开发的过程中，手写"),v("code",[e._v("render")]),e._v("方法的地方比较少，而手写最多的就是"),v("code",[e._v("template")]),e._v("模板，在之前的"),v("code",[e._v("mounted")]),e._v("方法的实现中，会把"),v("code",[e._v("template")]),e._v("编译成为"),v("code",[e._v("render")]),e._v("方法。")]),e._v(" "),v("p",[e._v("在这里，我们又遇到了一个"),v("code",[e._v("_render")]),e._v("和"),v("code",[e._v("render")]),e._v("，读者要注意不能弄混它们。")]),e._v(" "),v("p",[e._v("熟悉Vue使用的小伙伴应该知道，"),v("code",[e._v("render")]),e._v("函数的第一个参数是"),v("code",[e._v("createElement")]),e._v("。我们写好的的"),v("code",[e._v("render")]),e._v("函数会在"),v("code",[e._v("_render")]),e._v("方法中被调用。我们写的"),v("code",[e._v("createElement")]),e._v("方法具体传到Vue内部是怎么实现的呢？事实上他是在调用"),v("code",[e._v("initRender")]),e._v("的时候被动态的声明，和它一起声明的还有"),v("code",[e._v("_c")]),e._v("，他们两个功能一样，区别在于一个是处理内部编译的模板，一个是处理用户手写的渲染方法。")]),e._v(" "),v("h2",{attrs:{id:"虚拟节点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟节点"}},[e._v("#")]),e._v(" 虚拟节点")]),e._v(" "),v("p",[v("code",[e._v("vm._render")]),e._v("是调用"),v("code",[e._v("createElement")]),e._v("生成了"),v("code",[e._v("vnode")]),e._v("，他是一个虚拟"),v("code",[e._v("node")]),e._v(",我们要看看"),v("code",[e._v("createElement")]),e._v("具体实现，在这之前我们需要先了解一下什么是虚拟DOM。")]),e._v(" "),v("p",[e._v("首先我们肯定都知道什么是DOM,文档对象模型,他是用来描述一个文档内容和结构的抽象标准，提供了相当多的接口供我们实现具体对文档内容和结构的操作。如果我们打开浏览器输出一下一个DOM对象的内容，可以发现他是非常庞大的，因为浏览器的标准把DOM设计的十分复杂，所以当我们去更新一个DOM元素的时候，会产生一定的性能问题。")]),e._v(" "),v("p",[e._v("为了是我们的框架能够拥有更高的性能，Vue引入了Virtual DOM概念。将原生DOM抽象为一个简单的对象，内容上不必完全重现DOM,只要提供核心的Vue用的到的概念就可以，这就比创建一个真实DOM代价小得多。")]),e._v(" "),v("p",[e._v("在Vue.js中，Virtual DOM使用"),v("code",[e._v("VNode")]),e._v("这么一个"),v("code",[e._v("class")]),e._v("去秒速的，他定义在src/core/vdom/vnode.js中。")]),e._v(" "),v("p",[e._v("通过阅读源码我们可以看到，VNode的内容比真实DOM要少得多，但是同时他也会富含一些Vue需要的特别的特性，在生成一个VNode实例之后，想要渲染成真实DOM实际上需要经历"),v("code",[e._v("create")]),e._v(","),v("code",[e._v("diff")]),e._v(","),v("code",[e._v("patch")]),e._v("等过程。"),v("code",[e._v("createElement")]),e._v("就是产生VNode的函数。")]),e._v(" "),v("h2",{attrs:{id:"vnode的产生"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vnode的产生"}},[e._v("#")]),e._v(" VNode的产生")]),e._v(" "),v("p",[e._v("Vue.js 是使用"),v("code",[e._v("createElement")]),e._v("方法创建VNode的，定义在src/core/vnode/create-element.js中，它实际上是对_createElement方法的一层封装，它允许入参更加灵活，在处理完这些参数后，调用真实的"),v("code",[e._v("_createElement")]),e._v("真正创建"),v("code",[e._v("VNode")]),e._v("。")]),e._v(" "),v("p",[v("code",[e._v("_createElement")]),e._v("方法有5个参数")]),e._v(" "),v("ul",[v("li",[e._v("context 表示VNode的上下文环境，他是Component类型。")]),e._v(" "),v("li",[e._v("tag 表示标签，他可以是字符串或者component。")]),e._v(" "),v("li",[e._v("data 表示一个VNode数据，他是一个VNodeData，定义在flow/vnode.js中。")]),e._v(" "),v("li",[e._v("children 当前Vnode的子节点，他是任意类型的，它接下来需要被规范为标准的VNode数组。")]),e._v(" "),v("li",[e._v("normalizationType 子节点规范的类型，类型不同规范的方法也不一样，他主要是依据render函数是编译生成的还是用户手写的。")])]),e._v(" "),v("p",[e._v("虽然"),v("code",[e._v("createElement")]),e._v("函数流程有些复杂，但是我们可以把它重点分析为"),v("code",[e._v("children")]),e._v("规范化和"),v("code",[e._v("VNode")]),e._v("创建俩部分。")]),e._v(" "),v("h3",{attrs:{id:"children规范化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#children规范化"}},[e._v("#")]),e._v(" children规范化")]),e._v(" "),v("p",[e._v("由于Virtual DOM实际上是一个树状结构，每一个"),v("code",[e._v("VNode")]),e._v("可能会有多个子节点，这些子节点应该也是"),v("code",[e._v("VNode")]),e._v("类型。"),v("code",[e._v("_createElement")]),e._v("接受的第4个入参是任意类型，因此我们需要把它规范成为一个VNode类型。")]),e._v(" "),v("p",[e._v("这里根据"),v("code",[e._v("normalizationType")]),e._v("的差别，调用了"),v("code",[e._v("normalizeChildren(children)")]),e._v("和"),v("code",[e._v("simpleNormalizeChildren(children)")]),e._v("方法，他们的定义都在src/core/vdom/helpers/normalizieChildren.js```中。")]),e._v(" "),v("p",[e._v("根据注释我们知道这两个函数调用的不同：")]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("simpleNormalizeChildren")]),e._v("方法调用场景是"),v("code",[e._v("render")]),e._v("函数是编译生成的。理论上编译生成的"),v("code",[e._v("children")]),e._v("已经是Vnode类型，但是有一个例外的情况"),v("code",[e._v("functional component")]),e._v("函数式组件返回的是一个数组而不是一个节点,所以会通过"),v("code",[e._v("Array.prototype.concat")]),e._v("方法把整个"),v("code",[e._v("children")]),e._v("数组变成一个一维数组。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("normalizieChildren")]),e._v("方法的调用场景有两种。一个场景是"),v("code",[e._v("render")]),e._v("函数是用户手写的，当"),v("code",[e._v("children")]),e._v("只有一个节点的时候，Vue.js 从接口层面允许用户把"),v("code",[e._v("children")]),e._v("写成基础类型创建简单的文本节点，这种情况会调用createTextVNode生成一个文本节点的VNode;另一个场景是当编译"),v("code",[e._v("slot")]),e._v(","),v("code",[e._v("v-for")]),e._v("时会产生嵌套数组的情况，会调用"),v("code",[e._v("normalizeArrayChildren")]),e._v("方法。")])])]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("normalizeArrayChildren")]),e._v("方法接受2个入参；"),v("code",[e._v("children")]),e._v("表示需要规范的子节点，"),v("code",[e._v("nestedIndex")]),e._v("表示嵌套的索引，因为单个"),v("code",[e._v("child")]),e._v("可能是一个数组类型。"),v("code",[e._v("normalizeArrayChildren")]),e._v("主要的逻辑就是遍历"),v("code",[e._v("children")]),e._v(",获得单个节点"),v("code",[e._v("c")]),e._v(",然后对"),v("code",[e._v("c")]),e._v("的类型判断，如果是一个数组类型，就递归处理；如果是基础类型，就通过"),v("code",[e._v("createTextVNode")]),e._v("方法转换成VNode类型；最后，如果两种都不是，就已经是VNode类型的了，如果"),v("code",[e._v("children")]),e._v("是一个列表并且列表还存在嵌套的情况，就会根据"),v("code",[e._v("nestIndex")]),e._v("去更新他的"),v("code",[e._v("key")]),e._v("。这里需要注意，这三种情况中的text节点如果有两个连续的，就会合并成一个。")])]),e._v(" "),v("p",[e._v("通过对children的规范化，children变成了一个类型的VNode的Array.")]),e._v(" "),v("h3",{attrs:{id:"虚拟节点的创建"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟节点的创建"}},[e._v("#")]),e._v(" 虚拟节点的创建")]),e._v(" "),v("p",[e._v("回到"),v("code",[e._v("createElement")]),e._v("函数，规范化children之后，接下来会创建一个VNode。")]),e._v(" "),v("p",[e._v("创建VNode时，会先对tag做判断")]),e._v(" "),v("ul",[v("li",[e._v("如果是string，则接着判断如果是内置的一些节点，则直接创建一个普通VNode。如果是已经创建的组件名，就会调用createElement创建一个组件类型的Vnode节点。否则创建未知的标签VNode。")]),e._v(" "),v("li",[e._v("tag是一个Component类型，则直接调用CreateComponent创建组件类型的VNode。")])]),e._v(" "),v("h1",{attrs:{id:"update"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#update"}},[e._v("#")]),e._v(" update")]),e._v(" "),v("p",[e._v("我们已经深入了好几层了，让我们做个总结，以避免有些同学迷路了。")]),e._v(" "),v("p",[e._v("通过前面的分析，我们了解了，new Vue之后会调用_init方法进行初始化工作，这个过程会合并配置，初始化生命周期，初始化事件中心，初始化渲染，调用beforeCreate钩子，初始化data等数据，创建监听，执行created钩子。")]),e._v(" "),v("p",[e._v("初始化之后回调用vm.$mount方法挂载DOM,在挂载的时候回执行_render生成虚拟DOM和_update渲染DOM。")]),e._v(" "),v("p",[e._v("在执行_render的时候会调用_createElement方法实际生成VNode,这个过程会进行children的规范化一节VNode最终生成。")]),e._v(" "),v("p",[e._v("我们发现，整个$mount方法实际上到现在为止还没结束。")]),e._v(" "),v("p",[e._v("接下来，我们分析一下，虚拟DOM是如何一步步变成页面的。")]),e._v(" "),v("p",[e._v("Vue.js的_update是实例的私有方法，他被调用时机有2个：首次渲染，数据更新。")]),e._v(" "),v("p",[e._v("我们在这一章节只分析首次渲染部分。")]),e._v(" "),v("p",[e._v("_update方法吧VNode渲染为真实DOM,它定义在src/core/instance/lifecycle.js中。")]),e._v(" "),v("p",[e._v("_update的核心就是调用vm.__patch__方法，这个方法是因平台而异的。在web平台中，他的定义在src/platforms/web/runtime/index.js中。")]),e._v(" "),v("div",{staticClass:"language-javascript extra-class"},[v("pre",{pre:!0,attrs:{class:"language-javascript"}},[v("code",[v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Vue")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("prototype"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("__patch__ "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" inBrowser "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),e._v(" patch "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" noop"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),v("p",[e._v("可以看出，在web平台上，是否是服务端渲染也会产生影响。在服务端渲染中，没有真实的浏览器DOM环境，所以不需要把VNode最终转换成DOM,因此是一个空函数。在浏览器渲染中，它指向了patch方法，这个方法定义runtime/patch.js中。")]),e._v(" "),v("p",[e._v("该方法调用了"),v("code",[e._v("createPatchFunction")]),e._v("方法的返回值，这里传入了一个对象，包含"),v("code",[e._v("nodeOps")]),e._v("参数和"),v("code",[e._v("modules")]),e._v("参数。其中，"),v("code",[e._v("nodeOps")]),e._v("定义了一些DOM方法，"),v("code",[e._v("modules")]),e._v("定义了一些模块的钩子函数实现，它定义在src/core/vdom/patch.js中。")]),e._v(" "),v("p",[v("code",[e._v("createFatchFunction")]),e._v("定义了一系列辅助方法，最终返回了"),v("code",[e._v("patch")]),e._v("函数，这个方法就赋值给了"),v("code",[e._v("vm._update")]),e._v("函数里调用的"),v("code",[e._v("vm.__patch__")]),e._v("。")])])}),[],!1,null,null,null);t.default=a.exports}}]);