{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{214:function(e,o,v){\"use strict\";v.r(o);var _=v(0),t=Object(_.a)({},(function(){var e=this,o=e.$createElement,v=e._self._c||o;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[v(\"h1\",{attrs:{id:\"webpack-中蕴含的前端知识（一）\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#webpack-中蕴含的前端知识（一）\"}},[e._v(\"#\")]),e._v(\" webpack 中蕴含的前端知识（一）\")]),e._v(\" \"),v(\"h2\",{attrs:{id:\"关于-node-module-和-es6-module-的不同之处\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#关于-node-module-和-es6-module-的不同之处\"}},[e._v(\"#\")]),e._v(\" 关于 node module 和 ES6 module 的不同之处\")]),e._v(\" \"),v(\"h3\",{attrs:{id:\"从模块化说起\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#从模块化说起\"}},[e._v(\"#\")]),e._v(\" 从模块化说起\")]),e._v(\" \"),v(\"p\",[e._v(\"我们现在都已经知道，前端的模块化是一个逐步成长的过程。\\n\"),v(\"code\",[e._v(\"AMD\")]),e._v(\"，\"),v(\"code\",[e._v(\"CMD\")]),e._v(\"，\"),v(\"code\",[e._v(\"CommonJS\")]),e._v(\"，\"),v(\"code\",[e._v(\"ES6 module\")]),e._v(\"是分别在不同场景下不同历史时期提出的模块化概念。\")]),e._v(\" \"),v(\"p\",[e._v(\"我们今天的主角是\"),v(\"code\",[e._v(\"CommonJS\")]),e._v(\"和\"),v(\"code\",[e._v(\"ES6 module\")]),e._v(\"这两个标准，他们有很多相似的地方，又有很多不同之处。如果我们弄懂了这两种模块的标准，我们也就基本弄懂了现在JS的模块标准了。\")]),e._v(\" \"),v(\"h3\",{attrs:{id:\"commonjs\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#commonjs\"}},[e._v(\"#\")]),e._v(\" CommonJS\")]),e._v(\" \"),v(\"p\",[v(\"code\",[e._v(\"CommonJS\")]),e._v(\" 是由 \"),v(\"code\",[e._v(\"JavaScript\")]),e._v(\" 组织于2009年提出的包含模块，文件，IO，控制台在内的一系列标准。在\"),v(\"code\",[e._v(\"Node.js\")]),e._v(\"实现中采用了\"),v(\"code\",[e._v(\"CommonJS\")]),e._v(\"标准的一部分。但是\"),v(\"code\",[e._v(\"Node.js\")]),e._v(\"做了一些调整，现在谈到\"),v(\"code\",[e._v(\"CommonJS\")]),e._v(\"一般都是\"),v(\"code\",[e._v(\"Node.js\")]),e._v(\"中的概念，而不是原始的概念了。\")]),e._v(\" \"),v(\"p\",[e._v(\"最初，\"),v(\"code\",[e._v(\"CommonJS\")]),e._v(\"只在服务端，后来有了\"),v(\"code\",[e._v(\"Browserify\")]),e._v(\"(一个运行在\"),v(\"code\",[e._v(\"Node.js\")]),e._v(\"下的模块打包工具)，它可以将\"),v(\"code\",[e._v(\"CommonJS\")]),e._v(\"模块打包为浏览器可以运行的单个文件，所以，\"),v(\"code\",[e._v(\"CommonJS\")]),e._v(\"标准下的代码也可以运行在浏览器和客户端环境下了。\")]),e._v(\" \"),v(\"h4\",{attrs:{id:\"模块，导出和导入\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#模块，导出和导入\"}},[e._v(\"#\")]),e._v(\" 模块，导出和导入\")]),e._v(\" \"),v(\"p\",[v(\"code\",[e._v(\"CommonJS\")]),e._v(\"规定每个JS文件是一个模块，当一个模块中引入另一个模块的时候不会造成全局污染。\")]),e._v(\" \"),v(\"p\",[e._v(\"模块向外暴露自身的唯一办法就是导出，通过语法\"),v(\"code\",[e._v(\"module.exports\")]),e._v(\"可以导出模块中的内容，他可以直接写成\"),v(\"code\",[e._v(\"exports\")]),e._v(\",我们可以把二者这样看待:\")]),e._v(\" \"),v(\"div\",{staticClass:\"language-javascript extra-class\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[v(\"code\",[v(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"var\")]),e._v(\" exports \"),v(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[e._v(\"=\")]),e._v(\" module\"),v(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\".\")]),e._v(\"exports\"),v(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\";\")]),e._v(\"\\n\")])])]),v(\"p\",[e._v(\"所以，我们现在也同时知道了，我们只可以操作\"),v(\"code\",[e._v(\"exports\")]),e._v(\"这个‘指针’,不能为它赋值。\")]),e._v(\" \"),v(\"p\",[e._v(\"在\"),v(\"code\",[e._v(\"CommonJS\")]),e._v(\"导入其他模块的方法是用\"),v(\"code\",[e._v(\"require\")]),e._v(\"，在\"),v(\"code\",[e._v(\"require\")]),e._v(\"执行的时候可以分为两种情况：\")]),e._v(\" \"),v(\"ul\",[v(\"li\",[e._v(\"第一次加载模块，这是首先会执行该模块再导出内容。\")]),e._v(\" \"),v(\"li\",[e._v(\"模块已经被加载过了，此时不再执行，直接导出上次执行的结果。\")])]),e._v(\" \"),v(\"p\",[e._v(\"有时候我们只需要加载一个模块然后把它挂载至全局变量上，此时我们只要\"),v(\"code\",[e._v(\"require\")]),e._v(\"即可。\\n\"),v(\"code\",[e._v(\"require\")]),e._v(\"可以接受一个表达式，所以我们可以动态的加载一个模块。\")])])}),[],!1,null,null,null);o.default=t.exports}}]);","extractedComments":[]}